# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from concert_msgs/ConcertClients.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import concert_msgs.msg
import rocon_std_msgs.msg
import gateway_msgs.msg
import rocon_app_manager_msgs.msg

class ConcertClients(genpy.Message):
  _md5sum = "dc25b17de2f711f3b3dcaacf8d8f58eb"
  _type = "concert_msgs/ConcertClients"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """
# Clients that have been invited to this concert and can be used
concert_msgs/ConcertClient[] clients

# Clients that have disappeared from the gateway network without formally leaving. 
# Usually this will mean they have dropped off the wireless
concert_msgs/ConcertClient[] missing_clients

# Clients that are on the gateway network, but haven't been invited by this concert yet
# We do not have any implementation that can invite except by a conductor's auto_invite yet.
concert_msgs/ConcertClient[] uninvited_clients

================================================================================
MSG: concert_msgs/ConcertClient

# The concert alias
string name

# The unfriendly gateway name with the uuid suffix.
string gateway_name

# Platform information about the concert client.
rocon_std_msgs/PlatformInfo platform_info

# Is on the same machine ip as the conductor
bool is_local_client

# State of the concert client, see ConcertClientState.msg for string constants
# PENDING, BUSY, BLOCKING, BAD, JOINING, UNINVITED, AVAILABLE, MISSING, GONE 
string state

# Statistics
string ip
gateway_msgs/ConnectionStatistics conn_stats
# time last_connection_timestamp

rocon_app_manager_msgs/Rapp[] rapps

================================================================================
MSG: rocon_std_msgs/PlatformInfo
# Provides platform details for robots, software or human
# interactive devices.

########################### Variables ###########################

# rocon universal resource identifier
string uri
# rocon version compatibility identifier (used when connecting to concerts)
string version
Icon icon

================================================================================
MSG: rocon_std_msgs/Icon
# Used to idenfity the original package/filename resource this icon was/is to be loaded from
# This typically doesn't have to be set, but can be very useful when loading icons from yaml definitions.
string resource_name

# Image data format.  "jpeg" or "png"
string format

# Image data.
uint8[] data
================================================================================
MSG: gateway_msgs/ConnectionStatistics
# Constants
int8 WIRED = 1
int8 WIRELESS = 2
int32 MAX_TTL = 86400

# Gateway ping indicators
bool gateway_available
int64 time_since_last_seen #time in seconds since last ping successful
float32 ping_latency_min
float32 ping_latency_max
float32 ping_latency_avg
float32 ping_latency_mdev #mean absolute deviation

# Gateway network information indicators
bool network_info_available
int8 network_type
float32 wireless_bitrate
int8 wireless_link_quality
float32 wireless_signal_level
float32 wireless_noise_level



================================================================================
MSG: rocon_app_manager_msgs/Rapp
# This is the message that gets published in list_rapps. Do not think of it as the
# 'rapp' definition (since that is quite varied -> ancestor, virtual, child, implementation)
# Rather it is the published list of rapps with the required information for the concert
# and some introspection.

# app name (ros resource name format, i.e. pkg/name, e.g. turtle_concert/teleop)
string name
# user-friendly display name
string display_name
string description
# a rocon uri string indicating platform compatibility
string compatibility
string status

# a list of implementations
string[] implementations

# A preferred rapp for virtual rapp
string preferred

# icon for showing the app
rocon_std_msgs/Icon icon

# public interface and parameters
rocon_std_msgs/KeyValue[] public_interface
rocon_std_msgs/KeyValue[] public_parameters

================================================================================
MSG: rocon_std_msgs/KeyValue
string key
string value"""
  __slots__ = ['clients','missing_clients','uninvited_clients']
  _slot_types = ['concert_msgs/ConcertClient[]','concert_msgs/ConcertClient[]','concert_msgs/ConcertClient[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       clients,missing_clients,uninvited_clients

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ConcertClients, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.clients is None:
        self.clients = []
      if self.missing_clients is None:
        self.missing_clients = []
      if self.uninvited_clients is None:
        self.uninvited_clients = []
    else:
      self.clients = []
      self.missing_clients = []
      self.uninvited_clients = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.clients)
      buff.write(_struct_I.pack(length))
      for val1 in self.clients:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.gateway_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v1 = val1.platform_info
        _x = _v1.uri
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v1.version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v2 = _v1.icon
        _x = _v2.resource_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v2.format
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v2.data
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_B.pack(val1.is_local_client))
        _x = val1.state
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.ip
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v3 = val1.conn_stats
        _x = _v3
        buff.write(_struct_Bq4fBbfb2f.pack(_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level))
        length = len(val1.rapps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.rapps:
          _x = val2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.display_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.description
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.compatibility
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.status
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.implementations)
          buff.write(_struct_I.pack(length))
          for val3 in val2.implementations:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *val3))
            else:
              buff.write(struct.pack('<I%ss'%length, length, val3))
          _x = val2.preferred
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _v4 = val2.icon
          _x = _v4.resource_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v4.format
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v4.data
          length = len(_x)
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_interface)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_interface:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_parameters)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_parameters:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.missing_clients)
      buff.write(_struct_I.pack(length))
      for val1 in self.missing_clients:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.gateway_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v5 = val1.platform_info
        _x = _v5.uri
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v5.version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v6 = _v5.icon
        _x = _v6.resource_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v6.format
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v6.data
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_B.pack(val1.is_local_client))
        _x = val1.state
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.ip
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v7 = val1.conn_stats
        _x = _v7
        buff.write(_struct_Bq4fBbfb2f.pack(_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level))
        length = len(val1.rapps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.rapps:
          _x = val2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.display_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.description
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.compatibility
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.status
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.implementations)
          buff.write(_struct_I.pack(length))
          for val3 in val2.implementations:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *val3))
            else:
              buff.write(struct.pack('<I%ss'%length, length, val3))
          _x = val2.preferred
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _v8 = val2.icon
          _x = _v8.resource_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v8.format
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v8.data
          length = len(_x)
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_interface)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_interface:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_parameters)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_parameters:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.uninvited_clients)
      buff.write(_struct_I.pack(length))
      for val1 in self.uninvited_clients:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.gateway_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v9 = val1.platform_info
        _x = _v9.uri
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v9.version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v10 = _v9.icon
        _x = _v10.resource_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v10.format
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v10.data
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_B.pack(val1.is_local_client))
        _x = val1.state
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.ip
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v11 = val1.conn_stats
        _x = _v11
        buff.write(_struct_Bq4fBbfb2f.pack(_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level))
        length = len(val1.rapps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.rapps:
          _x = val2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.display_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.description
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.compatibility
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.status
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.implementations)
          buff.write(_struct_I.pack(length))
          for val3 in val2.implementations:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *val3))
            else:
              buff.write(struct.pack('<I%ss'%length, length, val3))
          _x = val2.preferred
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _v12 = val2.icon
          _x = _v12.resource_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v12.format
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v12.data
          length = len(_x)
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_interface)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_interface:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_parameters)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_parameters:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.clients is None:
        self.clients = None
      if self.missing_clients is None:
        self.missing_clients = None
      if self.uninvited_clients is None:
        self.uninvited_clients = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.clients = []
      for i in range(0, length):
        val1 = concert_msgs.msg.ConcertClient()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.gateway_name = str[start:end].decode('utf-8')
        else:
          val1.gateway_name = str[start:end]
        _v13 = val1.platform_info
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v13.uri = str[start:end].decode('utf-8')
        else:
          _v13.uri = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v13.version = str[start:end].decode('utf-8')
        else:
          _v13.version = str[start:end]
        _v14 = _v13.icon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v14.resource_name = str[start:end].decode('utf-8')
        else:
          _v14.resource_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v14.format = str[start:end].decode('utf-8')
        else:
          _v14.format = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v14.data = str[start:end]
        start = end
        end += 1
        (val1.is_local_client,) = _struct_B.unpack(str[start:end])
        val1.is_local_client = bool(val1.is_local_client)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state = str[start:end].decode('utf-8')
        else:
          val1.state = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.ip = str[start:end].decode('utf-8')
        else:
          val1.ip = str[start:end]
        _v15 = val1.conn_stats
        _x = _v15
        start = end
        end += 40
        (_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level,) = _struct_Bq4fBbfb2f.unpack(str[start:end])
        _v15.gateway_available = bool(_v15.gateway_available)
        _v15.network_info_available = bool(_v15.network_info_available)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.rapps = []
        for i in range(0, length):
          val2 = rocon_app_manager_msgs.msg.Rapp()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.name = str[start:end].decode('utf-8')
          else:
            val2.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.display_name = str[start:end].decode('utf-8')
          else:
            val2.display_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.description = str[start:end].decode('utf-8')
          else:
            val2.description = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.compatibility = str[start:end].decode('utf-8')
          else:
            val2.compatibility = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.status = str[start:end].decode('utf-8')
          else:
            val2.status = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.implementations = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8')
            else:
              val3 = str[start:end]
            val2.implementations.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.preferred = str[start:end].decode('utf-8')
          else:
            val2.preferred = str[start:end]
          _v16 = val2.icon
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v16.resource_name = str[start:end].decode('utf-8')
          else:
            _v16.resource_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v16.format = str[start:end].decode('utf-8')
          else:
            _v16.format = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          _v16.data = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_interface = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_interface.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_parameters = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_parameters.append(val3)
          val1.rapps.append(val2)
        self.clients.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.missing_clients = []
      for i in range(0, length):
        val1 = concert_msgs.msg.ConcertClient()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.gateway_name = str[start:end].decode('utf-8')
        else:
          val1.gateway_name = str[start:end]
        _v17 = val1.platform_info
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v17.uri = str[start:end].decode('utf-8')
        else:
          _v17.uri = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v17.version = str[start:end].decode('utf-8')
        else:
          _v17.version = str[start:end]
        _v18 = _v17.icon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v18.resource_name = str[start:end].decode('utf-8')
        else:
          _v18.resource_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v18.format = str[start:end].decode('utf-8')
        else:
          _v18.format = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v18.data = str[start:end]
        start = end
        end += 1
        (val1.is_local_client,) = _struct_B.unpack(str[start:end])
        val1.is_local_client = bool(val1.is_local_client)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state = str[start:end].decode('utf-8')
        else:
          val1.state = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.ip = str[start:end].decode('utf-8')
        else:
          val1.ip = str[start:end]
        _v19 = val1.conn_stats
        _x = _v19
        start = end
        end += 40
        (_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level,) = _struct_Bq4fBbfb2f.unpack(str[start:end])
        _v19.gateway_available = bool(_v19.gateway_available)
        _v19.network_info_available = bool(_v19.network_info_available)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.rapps = []
        for i in range(0, length):
          val2 = rocon_app_manager_msgs.msg.Rapp()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.name = str[start:end].decode('utf-8')
          else:
            val2.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.display_name = str[start:end].decode('utf-8')
          else:
            val2.display_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.description = str[start:end].decode('utf-8')
          else:
            val2.description = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.compatibility = str[start:end].decode('utf-8')
          else:
            val2.compatibility = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.status = str[start:end].decode('utf-8')
          else:
            val2.status = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.implementations = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8')
            else:
              val3 = str[start:end]
            val2.implementations.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.preferred = str[start:end].decode('utf-8')
          else:
            val2.preferred = str[start:end]
          _v20 = val2.icon
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v20.resource_name = str[start:end].decode('utf-8')
          else:
            _v20.resource_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v20.format = str[start:end].decode('utf-8')
          else:
            _v20.format = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          _v20.data = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_interface = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_interface.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_parameters = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_parameters.append(val3)
          val1.rapps.append(val2)
        self.missing_clients.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.uninvited_clients = []
      for i in range(0, length):
        val1 = concert_msgs.msg.ConcertClient()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.gateway_name = str[start:end].decode('utf-8')
        else:
          val1.gateway_name = str[start:end]
        _v21 = val1.platform_info
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v21.uri = str[start:end].decode('utf-8')
        else:
          _v21.uri = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v21.version = str[start:end].decode('utf-8')
        else:
          _v21.version = str[start:end]
        _v22 = _v21.icon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v22.resource_name = str[start:end].decode('utf-8')
        else:
          _v22.resource_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v22.format = str[start:end].decode('utf-8')
        else:
          _v22.format = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v22.data = str[start:end]
        start = end
        end += 1
        (val1.is_local_client,) = _struct_B.unpack(str[start:end])
        val1.is_local_client = bool(val1.is_local_client)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state = str[start:end].decode('utf-8')
        else:
          val1.state = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.ip = str[start:end].decode('utf-8')
        else:
          val1.ip = str[start:end]
        _v23 = val1.conn_stats
        _x = _v23
        start = end
        end += 40
        (_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level,) = _struct_Bq4fBbfb2f.unpack(str[start:end])
        _v23.gateway_available = bool(_v23.gateway_available)
        _v23.network_info_available = bool(_v23.network_info_available)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.rapps = []
        for i in range(0, length):
          val2 = rocon_app_manager_msgs.msg.Rapp()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.name = str[start:end].decode('utf-8')
          else:
            val2.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.display_name = str[start:end].decode('utf-8')
          else:
            val2.display_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.description = str[start:end].decode('utf-8')
          else:
            val2.description = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.compatibility = str[start:end].decode('utf-8')
          else:
            val2.compatibility = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.status = str[start:end].decode('utf-8')
          else:
            val2.status = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.implementations = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8')
            else:
              val3 = str[start:end]
            val2.implementations.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.preferred = str[start:end].decode('utf-8')
          else:
            val2.preferred = str[start:end]
          _v24 = val2.icon
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v24.resource_name = str[start:end].decode('utf-8')
          else:
            _v24.resource_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v24.format = str[start:end].decode('utf-8')
          else:
            _v24.format = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          _v24.data = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_interface = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_interface.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_parameters = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_parameters.append(val3)
          val1.rapps.append(val2)
        self.uninvited_clients.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.clients)
      buff.write(_struct_I.pack(length))
      for val1 in self.clients:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.gateway_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v25 = val1.platform_info
        _x = _v25.uri
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v25.version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v26 = _v25.icon
        _x = _v26.resource_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v26.format
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v26.data
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_B.pack(val1.is_local_client))
        _x = val1.state
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.ip
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v27 = val1.conn_stats
        _x = _v27
        buff.write(_struct_Bq4fBbfb2f.pack(_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level))
        length = len(val1.rapps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.rapps:
          _x = val2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.display_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.description
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.compatibility
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.status
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.implementations)
          buff.write(_struct_I.pack(length))
          for val3 in val2.implementations:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *val3))
            else:
              buff.write(struct.pack('<I%ss'%length, length, val3))
          _x = val2.preferred
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _v28 = val2.icon
          _x = _v28.resource_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v28.format
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v28.data
          length = len(_x)
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_interface)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_interface:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_parameters)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_parameters:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.missing_clients)
      buff.write(_struct_I.pack(length))
      for val1 in self.missing_clients:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.gateway_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v29 = val1.platform_info
        _x = _v29.uri
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v29.version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v30 = _v29.icon
        _x = _v30.resource_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v30.format
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v30.data
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_B.pack(val1.is_local_client))
        _x = val1.state
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.ip
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v31 = val1.conn_stats
        _x = _v31
        buff.write(_struct_Bq4fBbfb2f.pack(_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level))
        length = len(val1.rapps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.rapps:
          _x = val2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.display_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.description
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.compatibility
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.status
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.implementations)
          buff.write(_struct_I.pack(length))
          for val3 in val2.implementations:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *val3))
            else:
              buff.write(struct.pack('<I%ss'%length, length, val3))
          _x = val2.preferred
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _v32 = val2.icon
          _x = _v32.resource_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v32.format
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v32.data
          length = len(_x)
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_interface)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_interface:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_parameters)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_parameters:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.uninvited_clients)
      buff.write(_struct_I.pack(length))
      for val1 in self.uninvited_clients:
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.gateway_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v33 = val1.platform_info
        _x = _v33.uri
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v33.version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v34 = _v33.icon
        _x = _v34.resource_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v34.format
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v34.data
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_struct_B.pack(val1.is_local_client))
        _x = val1.state
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.ip
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        if python3:
          buff.write(struct.pack('<I%sB'%length, length, *_x))
        else:
          buff.write(struct.pack('<I%ss'%length, length, _x))
        _v35 = val1.conn_stats
        _x = _v35
        buff.write(_struct_Bq4fBbfb2f.pack(_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level))
        length = len(val1.rapps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.rapps:
          _x = val2.name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.display_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.description
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.compatibility
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val2.status
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.implementations)
          buff.write(_struct_I.pack(length))
          for val3 in val2.implementations:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *val3))
            else:
              buff.write(struct.pack('<I%ss'%length, length, val3))
          _x = val2.preferred
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _v36 = val2.icon
          _x = _v36.resource_name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v36.format
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          if python3:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = _v36.data
          length = len(_x)
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(struct.pack('<I%sB'%length, length, *_x))
          else:
            buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_interface)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_interface:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
          length = len(val2.public_parameters)
          buff.write(_struct_I.pack(length))
          for val3 in val2.public_parameters:
            _x = val3.key
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = val3.value
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            if python3:
              buff.write(struct.pack('<I%sB'%length, length, *_x))
            else:
              buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.clients is None:
        self.clients = None
      if self.missing_clients is None:
        self.missing_clients = None
      if self.uninvited_clients is None:
        self.uninvited_clients = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.clients = []
      for i in range(0, length):
        val1 = concert_msgs.msg.ConcertClient()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.gateway_name = str[start:end].decode('utf-8')
        else:
          val1.gateway_name = str[start:end]
        _v37 = val1.platform_info
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v37.uri = str[start:end].decode('utf-8')
        else:
          _v37.uri = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v37.version = str[start:end].decode('utf-8')
        else:
          _v37.version = str[start:end]
        _v38 = _v37.icon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v38.resource_name = str[start:end].decode('utf-8')
        else:
          _v38.resource_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v38.format = str[start:end].decode('utf-8')
        else:
          _v38.format = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v38.data = str[start:end]
        start = end
        end += 1
        (val1.is_local_client,) = _struct_B.unpack(str[start:end])
        val1.is_local_client = bool(val1.is_local_client)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state = str[start:end].decode('utf-8')
        else:
          val1.state = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.ip = str[start:end].decode('utf-8')
        else:
          val1.ip = str[start:end]
        _v39 = val1.conn_stats
        _x = _v39
        start = end
        end += 40
        (_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level,) = _struct_Bq4fBbfb2f.unpack(str[start:end])
        _v39.gateway_available = bool(_v39.gateway_available)
        _v39.network_info_available = bool(_v39.network_info_available)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.rapps = []
        for i in range(0, length):
          val2 = rocon_app_manager_msgs.msg.Rapp()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.name = str[start:end].decode('utf-8')
          else:
            val2.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.display_name = str[start:end].decode('utf-8')
          else:
            val2.display_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.description = str[start:end].decode('utf-8')
          else:
            val2.description = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.compatibility = str[start:end].decode('utf-8')
          else:
            val2.compatibility = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.status = str[start:end].decode('utf-8')
          else:
            val2.status = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.implementations = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8')
            else:
              val3 = str[start:end]
            val2.implementations.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.preferred = str[start:end].decode('utf-8')
          else:
            val2.preferred = str[start:end]
          _v40 = val2.icon
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v40.resource_name = str[start:end].decode('utf-8')
          else:
            _v40.resource_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v40.format = str[start:end].decode('utf-8')
          else:
            _v40.format = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          _v40.data = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_interface = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_interface.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_parameters = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_parameters.append(val3)
          val1.rapps.append(val2)
        self.clients.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.missing_clients = []
      for i in range(0, length):
        val1 = concert_msgs.msg.ConcertClient()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.gateway_name = str[start:end].decode('utf-8')
        else:
          val1.gateway_name = str[start:end]
        _v41 = val1.platform_info
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v41.uri = str[start:end].decode('utf-8')
        else:
          _v41.uri = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v41.version = str[start:end].decode('utf-8')
        else:
          _v41.version = str[start:end]
        _v42 = _v41.icon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v42.resource_name = str[start:end].decode('utf-8')
        else:
          _v42.resource_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v42.format = str[start:end].decode('utf-8')
        else:
          _v42.format = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v42.data = str[start:end]
        start = end
        end += 1
        (val1.is_local_client,) = _struct_B.unpack(str[start:end])
        val1.is_local_client = bool(val1.is_local_client)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state = str[start:end].decode('utf-8')
        else:
          val1.state = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.ip = str[start:end].decode('utf-8')
        else:
          val1.ip = str[start:end]
        _v43 = val1.conn_stats
        _x = _v43
        start = end
        end += 40
        (_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level,) = _struct_Bq4fBbfb2f.unpack(str[start:end])
        _v43.gateway_available = bool(_v43.gateway_available)
        _v43.network_info_available = bool(_v43.network_info_available)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.rapps = []
        for i in range(0, length):
          val2 = rocon_app_manager_msgs.msg.Rapp()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.name = str[start:end].decode('utf-8')
          else:
            val2.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.display_name = str[start:end].decode('utf-8')
          else:
            val2.display_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.description = str[start:end].decode('utf-8')
          else:
            val2.description = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.compatibility = str[start:end].decode('utf-8')
          else:
            val2.compatibility = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.status = str[start:end].decode('utf-8')
          else:
            val2.status = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.implementations = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8')
            else:
              val3 = str[start:end]
            val2.implementations.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.preferred = str[start:end].decode('utf-8')
          else:
            val2.preferred = str[start:end]
          _v44 = val2.icon
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v44.resource_name = str[start:end].decode('utf-8')
          else:
            _v44.resource_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v44.format = str[start:end].decode('utf-8')
          else:
            _v44.format = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          _v44.data = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_interface = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_interface.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_parameters = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_parameters.append(val3)
          val1.rapps.append(val2)
        self.missing_clients.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.uninvited_clients = []
      for i in range(0, length):
        val1 = concert_msgs.msg.ConcertClient()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8')
        else:
          val1.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.gateway_name = str[start:end].decode('utf-8')
        else:
          val1.gateway_name = str[start:end]
        _v45 = val1.platform_info
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v45.uri = str[start:end].decode('utf-8')
        else:
          _v45.uri = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v45.version = str[start:end].decode('utf-8')
        else:
          _v45.version = str[start:end]
        _v46 = _v45.icon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v46.resource_name = str[start:end].decode('utf-8')
        else:
          _v46.resource_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v46.format = str[start:end].decode('utf-8')
        else:
          _v46.format = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v46.data = str[start:end]
        start = end
        end += 1
        (val1.is_local_client,) = _struct_B.unpack(str[start:end])
        val1.is_local_client = bool(val1.is_local_client)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state = str[start:end].decode('utf-8')
        else:
          val1.state = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.ip = str[start:end].decode('utf-8')
        else:
          val1.ip = str[start:end]
        _v47 = val1.conn_stats
        _x = _v47
        start = end
        end += 40
        (_x.gateway_available, _x.time_since_last_seen, _x.ping_latency_min, _x.ping_latency_max, _x.ping_latency_avg, _x.ping_latency_mdev, _x.network_info_available, _x.network_type, _x.wireless_bitrate, _x.wireless_link_quality, _x.wireless_signal_level, _x.wireless_noise_level,) = _struct_Bq4fBbfb2f.unpack(str[start:end])
        _v47.gateway_available = bool(_v47.gateway_available)
        _v47.network_info_available = bool(_v47.network_info_available)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.rapps = []
        for i in range(0, length):
          val2 = rocon_app_manager_msgs.msg.Rapp()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.name = str[start:end].decode('utf-8')
          else:
            val2.name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.display_name = str[start:end].decode('utf-8')
          else:
            val2.display_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.description = str[start:end].decode('utf-8')
          else:
            val2.description = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.compatibility = str[start:end].decode('utf-8')
          else:
            val2.compatibility = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.status = str[start:end].decode('utf-8')
          else:
            val2.status = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.implementations = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8')
            else:
              val3 = str[start:end]
            val2.implementations.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.preferred = str[start:end].decode('utf-8')
          else:
            val2.preferred = str[start:end]
          _v48 = val2.icon
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v48.resource_name = str[start:end].decode('utf-8')
          else:
            _v48.resource_name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            _v48.format = str[start:end].decode('utf-8')
          else:
            _v48.format = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          _v48.data = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_interface = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_interface.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.public_parameters = []
          for i in range(0, length):
            val3 = rocon_std_msgs.msg.KeyValue()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.key = str[start:end].decode('utf-8')
            else:
              val3.key = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3.value = str[start:end].decode('utf-8')
            else:
              val3.value = str[start:end]
            val2.public_parameters.append(val3)
          val1.rapps.append(val2)
        self.uninvited_clients.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_B = struct.Struct("<B")
_struct_Bq4fBbfb2f = struct.Struct("<Bq4fBbfb2f")
